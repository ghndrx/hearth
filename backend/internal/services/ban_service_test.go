package services

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// MockBanRepository is an autogenerated mock type for the BanRepository type
type MockBanRepository struct {
	mock.Mock
}

// InsertBan provides a mock function with given fields: ctx, userID, guildID, reason
func (_m *MockBanRepository) InsertBan(ctx context.Context, userID string, guildID string, reason string) error {
	ret := _m.Called(ctx, userID, guildID, reason)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, userID, guildID, reason)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteBan provides a mock function with given fields: ctx, userID, guildID
func (_m *MockBanRepository) DeleteBan(ctx context.Context, userID string, guildID string) error {
	ret := _m.Called(ctx, userID, guildID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, userID, guildID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBan provides a mock function with given fields: ctx, userID, guildID
func (_m *MockBanRepository) GetBan(ctx context.Context, userID string, guildID string) (*Ban, error) {
	ret := _m.Called(ctx, userID, guildID)

	var r0 *Ban
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*Ban, error)); ok {
		return rf(ctx, userID, guildID)
	}
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(*Ban)
	}
	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userID, guildID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBans provides a mock function with given fields: ctx, guildID
func (_m *MockBanRepository) ListBans(ctx context.Context, guildID string) ([]Ban, error) {
	ret := _m.Called(ctx, guildID)

	var r0 []Ban
	if rf, ok := ret.Get(0).(func(context.Context, string) []Ban); ok {
		r0 = rf(ctx, guildID)
	}
	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, guildID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetupTestTable is a helper function that sets up a fixed set of bans for testing
func SetupTestTable() []Ban {
	return []Ban{
		{
			UserID:     "123User1",
			GuildID:    "123Guild1",
			Reason:     "Spamming",
			CreatedAt:  1000000000,
			ModeratorID: "456Mod1",
		},
		{
			UserID:     "123User2",
			GuildID:    "123Guild1",
			Reason:     "Inappropriate content",
			CreatedAt:  1000000001,
			ModeratorID: "456Mod1",
		},
	}
}

func TestBanService_BanUser(t *testing.T) {
	tests := []struct {
		name         string
		userID       string
		guildID      string
		reason       string
		moderatorID  string
		mockBehavior func(*MockBanRepository)
		wantErr      bool
		errMsg       string
	}{
		{
			name:       "Successfully bans a user",
			userID:     "123User",
			guildID:    "123Guild",
			reason:     "Bad behavior",
			moderatorID: "Mod1",
			mockBehavior: func(m *MockBanRepository) {
				m.On("GetBan", mock.Anything, "123User", "123Guild").Return(nil, ErrUserNotBanned)
				m.On("InsertBan", mock.Anything, "123User", "123Guild", "Bad behavior").Return(nil)
			},
			wantErr: false,
		},
		{
			name:       "Returns error if user is already banned",
			userID:     "123User",
			guildID:    "123Guild",
			reason:     "Bad behavior",
			moderatorID: "Mod1",
			mockBehavior: func(m *MockBanRepository) {
				existingBan := &Ban{UserID: "123User"}
				m.On("GetBan", mock.Anything, "123User", "123Guild").Return(existingBan, nil)
			},
			wantErr: true,
			errMsg:  ErrUserAlreadyBanned.Error(),
		},
		{
			name:       "Returns error on repository failure",
			userID:     "123User",
			guildID:    "123Guild",
			reason:     "Bad behavior",
			moderatorID: "Mod1",
			mockBehavior: func(m *MockBanRepository) {
				m.On("GetBan", mock.Anything, "123User", "123Guild").Return(nil, ErrUserNotBanned)
				m.On("InsertBan", mock.Anything, "123User", "123Guild", "Bad behavior").Return(errors.New("db connection failed"))
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := new(MockBanRepository)
			svc := NewBanService(mockRepo)
			tt.mockBehavior(mockRepo)

			err := svc.BanUser(context.Background(), tt.userID, tt.guildID, tt.reason, tt.moderatorID)

			if tt.wantErr {
				assert.Error(t, err)
				assert.Equal(t, tt.errMsg, err.Error())
			} else {
				assert.NoError(t, err)
			}
			mockRepo.AssertExpectations(t)
		})
	}
}

func TestBanService_IsBanned(t *testing.T) {
	t.Run("User is banned", func(t *testing.T) {
		mockRepo := new(MockBanRepository)
		svc := NewBanService(mockRepo)

		mockRepo.On("GetBan", mock.Anything, "123User", "123Guild").Return(&Ban{UserID: "123User"}, nil)

		isBanned, err := svc.IsBanned(context.Background(), "123User", "123Guild")

		assert.True(t, isBanned)
		assert.NoError(t, err)
		mockRepo.AssertExpectations(t)
	})

	t.Run("User is not banned", func(t *testing.T) {
		mockRepo := new(MockBanRepository)
		svc := NewBanService(mockRepo)

		mockRepo.On("GetBan", mock.Anything, "123User", "123Guild").Return(nil, ErrUserNotBanned)

		isBanned, err := svc.IsBanned(context.Background(), "123User", "123Guild")

		assert.False(t, isBanned)
		assert.NoError(t, err)
		mockRepo.AssertExpectations(t)
	})

	t.Run("Repository error occurs", func(t *testing.T) {
		mockRepo := new(MockBanRepository)
		svc := NewBanService(mockRepo)

		mockRepo.On("GetBan", mock.Anything, "123User", "123Guild").Return(nil, errors.New("database failure"))

		isBanned, err := svc.IsBanned(context.Background(), "123User", "123Guild")

		assert.False(t, isBanned) // Service handles error by returning false under current logic
		assert.Error(t, err)
		mockRepo.AssertExpectations(t)
	})
}

func TestBanService_GetBans(t *testing.T) {
	mockRepo := new(MockBanRepository)
	svc := NewBanService(mockRepo)

	testData := SetupTestTable()

	mockRepo.On("ListBans", mock.Anything, "123Guild").Return(testData, nil)

	bans, err := svc.GetBans(context.Background(), "123Guild")

	assert.NoError(t, err)
	assert.Len(t, bans, 2)
	assert.Equal(t, "Spamming", bans[0].Reason)
	mockRepo.AssertExpectations(t)
}

// Note: Unban tests follow the same pattern as Ban tests